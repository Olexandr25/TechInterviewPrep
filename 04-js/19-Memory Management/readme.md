# Керування пам'яттю (Memory Management)

У мовах низького рівня (наприклад, C) є явні примітиви для управління пам'яттю (malloc/free). У JavaScript виділення пам'яті при створенні об'єктів і її звільнення (через збирач сміття) відбувається автоматично. Це спрощує роботу, але не означає, що проблеми з пам'яттю не потрібно враховувати.

---

## Життєвий цикл пам'яті

Завжди три кроки:

1. Виділити пам'ять.
2. Використовувати (читати/записувати).
3. Звільнити, коли не потрібна.

У JS виділення й звільнення більшість разів приховані від розробника.

---

## Виділення в JavaScript

- Примітиви, об'єкти, масиви, функції автоматично виділяються при оголошенні.
- Деякі виклики (new Date(), document.createElement(), методи рядків/масивів) також створюють нові об'єкти/значення.
- Використання — читання/запис змінних, передачі в функції тощо.

---

## Звільнення пам'яті і збирач сміття

Задача GC — визначити, що більше не потрібно, і звільнити пам'ять. Загальна проблема недетермінована, тому збирачі застосовують евристики.

Основна концепція — досяжність (reachability):

- Корені (roots): виконувана функція та її локальні змінні; стек викликів; глобальні змінні; інші внутрішні ресурси.
- Об'єкт вважається reachable, якщо до нього можна дістатися від коренів ланцюжком посилань.
- Немає посилань із коренів → об'єкт недосяжний → підлягає збору.

Приклад:

- let user = { name: "John" }; user = null; — об'єкт стає недосяжним і буде зібраний.

Важливо: взаємні посилання між об'єктами (острівці) не роблять їх живими, якщо вони недосяжні з коренів.

---

## Алгоритми GC

- Mark-and-sweep (основний у сучасних двигунах):
  1. Відзначити корені.
  2. Рекурсивно відзначити всі об'єкти, до яких можна дістатися.
  3. Видалити незмарковані об'єкти.
- Оптимізації:
  - Генераційна збірка (young/old): більшість об'єктів помирає швидко.
  - Інкрементальна збірка: дроблення роботи на частини, щоб уникати довгих пауз.
  - Idle-time / concurrent / parallel збірки для мінімізації затримок.

Примітка: старі алгоритми на базі лічильника посилань мають проблему циклів; сучасні рушії їх не використовують як основний метод.

---

## Налаштування середовища

У Node.js можна змінювати налаштування heap і включати діагностику:

- node --max-old-space-size=6000 index.js
- node --expose-gc --inspect index.js

У браузерах доступ до внутрішнього GC обмежений.

---

## Структури даних, що допомагають керувати пам'яттю

WeakMap / WeakSet

- Ключі зберігаються "слабо": якщо більше немає сильних посилань на ключ — ключ (а разом із ним і пов'язане значення в ідеалі) може бути зібраний.
- Можуть містити лише об'єкти/символи.
- Не ітеруються — це важливо для невтручального поводження зі збирачем сміття.
- Реальна механіка використовує еферемони/епіферемони в GC (не просто прості "слабкі" посилання).

WeakRef / FinalizationRegistry

- WeakRef — слабке посилання на об'єкт; дозволяє зберігати значення, яке може бути звільнене GC.
- FinalizationRegistry — реєстрація колбеку, який викликається після того, як об'єкт зібраний (без гарантій часу/надійності).
- Використовувати обережно: семантика ненадійна, колбеки можуть викликатися пізно або не викликатися взагалі. Підходять для оптимізацій (не для критичного логіки звільнення ресурсів).

Приклад кешу з WeakRef + FinalizationRegistry (узагальнення):

```js
function cached(getter) {
  const cache = new Map(); // ключ → WeakRef(value)
  const registry = new FinalizationRegistry((key) => {
    if (!cache.get(key)?.deref()) cache.delete(key);
  });
  return async (key) => {
    const wr = cache.get(key);
    const val = wr?.deref();
    if (val !== undefined) return val;
    const value = await getter(key);
    cache.set(key, new WeakRef(value));
    registry.register(value, key);
    return value;
  };
}
```

---

## Типові джерела витоків пам'яті

- Невмисні глобальні змінні (assign without let/const) — прив'язка до кореня.
- Таймери / колбеки (setInterval, незнятими слухачі) — поки активні, не дозволяють збирати пов'язані об'єкти.
- Посилання на видалені DOM-вузли — якщо JS зберігає посилання, вузол не звільниться.
- Замикання (closures) — збереження великих даних у лексичних середовищах, особливо якщо кожен виклик створює нову замкнуту функцію, що захоплює попередні значення.

Рекомендації:

- Уважно відключайте таймери та слухачі перед видаленням елементів.
- Обнуляйте великі посилання, якщо вони більше не потрібні.
- Переосмисліть API, коли closure зберігає великі об'єкти необґрунтовано.

---

## Підсумок

- GC у JS автоматичний; ключове поняття — досяжність (reachability).
- Сучасні рушії використовують mark-and-sweep з різними оптимізаціями.
- Одне правило: зробіть об'єкт недосяжним, щоб дозволити його звільнити.
- Використовуйте WeakMap/WeakSet, WeakRef та FinalizationRegistry обережно й лише для оптимізації довгоживучих структур.
- Для діагностики у Node — прапори та інструменти (heap snapshot, inspector).

---

## Interview Questions

- Що таке "reachability" і чому воно важливе для GC?
- Чим відрізняються reference-counting і mark-and-sweep? Чому сучасні рушії обирають mark-and-sweep?
- Які оптимізації GC ви знаєте (generational, incremental, concurrent, parallel)?
- Чим небезпечні циклічні посилання в контексті reference-counting?
- Що таке WeakMap/WeakSet, коли їх використовувати?
- Для чого потрібні WeakRef і FinalizationRegistry? Які їхні обмеження?
- Назвіть поширені причини витоків пам'яті у веб-додатках.
- Як відлагодити витік пам'яті у Node.js чи браузері (які інструменти/флаги)?

---

## What to Answer

- **"Reachability"** — це досяжність об'єкта від коренів (глобальні змінні, стек, локальні змінні). Якщо об'єкт недосяжний, GC може його видалити.
- **Reference-counting** рахує кількість посилань на об'єкт, але не справляється з циклічними посиланнями. **Mark-and-sweep** відмічає всі досяжні об'єкти, а потім очищає недосяжні; сучасні рушії JS використовують саме цей підхід через відсутність проблем із циклами.
- **Оптимізації GC:**
  - *Generational* — розділення об'єктів на "молоді" та "старі", більшість молодих швидко видаляються.
  - *Incremental* — розбиває збірку сміття на частини, щоб уникати довгих пауз.
  - *Concurrent/parallel* — частини GC виконуються паралельно з кодом або на кількох ядрах, зменшуючи затримки.
- **Циклічні посилання** при reference-counting не дозволяють зібрати об'єкти, навіть якщо вони недосяжні, що призводить до витоків пам'яті.
- **WeakMap/WeakSet** — структури, де ключі (або елементи) зберігаються "слабо": якщо на об'єкт більше немає сильних посилань, він може бути зібраний GC. Використовуються для кешів, асоціацій з об'єктами, які не повинні заважати їх звільненню.
- **WeakRef** дозволяє зберігати слабке посилання на об'єкт, а **FinalizationRegistry** — виконати колбек після його збору. Обмеження: не гарантують часу звільнення, колбек може не спрацювати вчасно або взагалі, тому не підходять для критичних дій.
- **Поширені причини витоків:**
  - Невидалені таймери/події (setInterval, addEventListener)
  - Збережені посилання на видалені DOM-вузли
  - Замикання, що утримують великі об'єкти
  - Глобальні змінні або випадкові присвоєння без let/const
- **Діагностика:**
  - *Node.js*: прапори `--inspect`, `--expose-gc`, heap snapshot у Chrome DevTools
  - *Браузер*: вкладка Memory у DevTools, heap snapshot, профілювання
  - В коді: вручну викликати `global.gc()` (якщо дозволено), аналізувати об'єкти, що не звільняються.
