# Керування пам'яттю (Memory Management)

У мовах низького рівня (наприклад, C) є явні примітиви для управління пам'яттю (malloc/free). У JavaScript виділення пам'яті при створенні об'єктів і її звільнення (через збирач сміття) відбувається автоматично. Це спрощує роботу, але не означає, що проблеми з пам'яттю не потрібно враховувати.

---

## Життєвий цикл пам'яті

Завжди три кроки:

1. Виділити пам'ять.
2. Використовувати (читати/записувати).
3. Звільнити, коли не потрібна.

У JS виділення й звільнення більшість разів приховані від розробника.

---

## Виділення в JavaScript

- Примітиви, об'єкти, масиви, функції автоматично виділяються при оголошенні.
- Деякі виклики (new Date(), document.createElement(), методи рядків/масивів) також створюють нові об'єкти/значення.
- Використання — читання/запис змінних, передачі в функції тощо.

---

## Звільнення пам'яті і збирач сміття

Задача GC — визначити, що більше не потрібно, і звільнити пам'ять. Загальна проблема недетермінована, тому збирачі застосовують евристики.

Основна концепція — досяжність (reachability):

- Корені (roots): виконувана функція та її локальні змінні; стек викликів; глобальні змінні; інші внутрішні ресурси.
- Об'єкт вважається reachable, якщо до нього можна дістатися від коренів ланцюжком посилань.
- Немає посилань із коренів → об'єкт недосяжний → підлягає збору.

Приклад:

- let user = { name: "John" }; user = null; — об'єкт стає недосяжним і буде зібраний.

Важливо: взаємні посилання між об'єктами (острівці) не роблять їх живими, якщо вони недосяжні з коренів.

---

## Алгоритми GC

- Mark-and-sweep (основний у сучасних двигунах):
  1. Відзначити корені.
  2. Рекурсивно відзначити всі об'єкти, до яких можна дістатися.
  3. Видалити незмарковані об'єкти.
- Оптимізації:
  - Генераційна збірка (young/old): більшість об'єктів помирає швидко.
  - Інкрементальна збірка: дроблення роботи на частини, щоб уникати довгих пауз.
  - Idle-time / concurrent / parallel збірки для мінімізації затримок.

Примітка: старі алгоритми на базі лічильника посилань мають проблему циклів; сучасні рушії їх не використовують як основний метод.

---

## Налаштування середовища

У Node.js можна змінювати налаштування heap і включати діагностику:

- node --max-old-space-size=6000 index.js
- node --expose-gc --inspect index.js

У браузерах доступ до внутрішнього GC обмежений.

---

## Структури даних, що допомагають керувати пам'яттю

WeakMap / WeakSet

- Ключі зберігаються "слабо": якщо більше немає сильних посилань на ключ — ключ (а разом із ним і пов'язане значення в ідеалі) може бути зібраний.
- Можуть містити лише об'єкти/символи.
- Не ітеруються — це важливо для невтручального поводження зі збирачем сміття.
- Реальна механіка використовує еферемони/епіферемони в GC (не просто прості "слабкі" посилання).

WeakRef / FinalizationRegistry

- WeakRef — слабке посилання на об'єкт; дозволяє зберігати значення, яке може бути звільнене GC.
- FinalizationRegistry — реєстрація колбеку, який викликається після того, як об'єкт зібраний (без гарантій часу/надійності).
- Використовувати обережно: семантика ненадійна, колбеки можуть викликатися пізно або не викликатися взагалі. Підходять для оптимізацій (не для критичного логіки звільнення ресурсів).

Приклад кешу з WeakRef + FinalizationRegistry (узагальнення):

```js
function cached(getter) {
  const cache = new Map(); // ключ → WeakRef(value)
  const registry = new FinalizationRegistry((key) => {
    if (!cache.get(key)?.deref()) cache.delete(key);
  });
  return async (key) => {
    const wr = cache.get(key);
    const val = wr?.deref();
    if (val !== undefined) return val;
    const value = await getter(key);
    cache.set(key, new WeakRef(value));
    registry.register(value, key);
    return value;
  };
}
```

---

## Типові джерела витоків пам'яті

- Невмисні глобальні змінні (assign without let/const) — прив'язка до кореня.
- Таймери / колбеки (setInterval, незнятими слухачі) — поки активні, не дозволяють збирати пов'язані об'єкти.
- Посилання на видалені DOM-вузли — якщо JS зберігає посилання, вузол не звільниться.
- Замикання (closures) — збереження великих даних у лексичних середовищах, особливо якщо кожен виклик створює нову замкнуту функцію, що захоплює попередні значення.

Рекомендації:

- Уважно відключайте таймери та слухачі перед видаленням елементів.
- Обнуляйте великі посилання, якщо вони більше не потрібні.
- Переосмисліть API, коли closure зберігає великі об'єкти необґрунтовано.

---

## Підсумок

- GC у JS автоматичний; ключове поняття — досяжність (reachability).
- Сучасні рушії використовують mark-and-sweep з різними оптимізаціями.
- Одне правило: зробіть об'єкт недосяжним, щоб дозволити його звільнити.
- Використовуйте WeakMap/WeakSet, WeakRef та FinalizationRegistry обережно й лише для оптимізації довгоживучих структур.
- Для діагностики у Node — прапори та інструменти (heap snapshot, inspector).

---

## Interview Questions

- Що таке "reachability" і чому воно важливе для GC?
- Чим відрізняються reference-counting і mark-and-sweep? Чому сучасні рушії обирають mark-and-sweep?
- Які оптимізації GC ви знаєте (generational, incremental, concurrent, parallel)?
- Чим небезпечні циклічні посилання в контексті reference-counting?
- Що таке WeakMap/WeakSet, коли їх використовувати?
- Для чого потрібні WeakRef і FinalizationRegistry? Які їхні обмеження?
- Назвіть поширені причини витоків пам'яті у веб-додатках.
- Як відлагодити витік пам'яті у Node.js чи браузері (які інструменти/флаги)?

---

## What to Answer

- Почніть з короткого визначення (1–2 речення), наприклад: "GC у JS видаляє об'єкти, недосяжні від коренів (reachability)."
- Наведіть ключову механіку: mark-and-sweep → відмітка коренів → рекурсивне відвідування → очищення не відмічених.
- Якщо питають про оптимізації — перелічіть generational, incremental, concurrent/parallel і коротко поясніть їхню мету (меньші паузи, ефективність).
- Для WeakMap/WeakSet/WeakRef/FinalizationRegistry — поясніть призначення і обмеження (не гарантують час звільнення, FinalizationRegistry ненадійний для критичних дій).
- При питаннях про витоки — наведіть практичний приклад (події, таймери, невидалені DOM-посилання, замикання) і коротко запропонуйте рішення (відписатися, обнуляти, використовувати слабкі структури для кешу).
- Якщо потрібно — додайте приклад коду (короткий) або опишіть, як зробити heap snapshot / використовувати node --expose-gc для діагностики.

