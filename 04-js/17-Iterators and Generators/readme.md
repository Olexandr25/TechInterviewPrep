# JavaScript — Ітератори, Ітеровані Об'єкти та Генератори

Файл пояснює сучасну ітерацію в JavaScript: for...of, протоколи ітератора та ітерованого об'єкта, генераторні функції та просунуті можливості генераторів. Структура нормалізована, повтори видалені.

---

## Швидкий зміст

- for...of
- Ітератори (iterator protocol)
- Ітеровані об'єкти (Symbol.iterator)
- Генератори (function*)
- Просунуті методи генераторів: return(), throw(), yield*

---

## for...of (коротко)

for...of ітерує будь-який ітерований об'єкт:

```js
const nums = [1, 5, 16];
for (const n of nums) {
  console.log(n); // 1, 5, 16
}
```

Внутрішньо викликає `obj[Symbol.iterator]()` щоб отримати ітератор і повторно звертається до `next()` поки не отримає `{ done: true }`.

---

## Ітератори (iterator protocol)

Ітератор — об'єкт з методом `next()`, що повертає `{ value, done }`.

Приклад простої фабрики ітератора:

```js
function makeIterator(array) {
  let i = 0;
  return {
    next() {
      if (i < array.length) return { value: array[i++], done: false };
      return { value: undefined, done: true };
    }
  };
}

const iter = makeIterator([1,5,16]);
iter.next(); // {value: 1, done:false}
iter.next(); // {value: 5, done:false}
iter.next(); // {value: 16, done:false}
iter.next(); // {value: undefined, done:true}
```

Вбудовані ітератори існують для Array, String, Map, Set, typed arrays, DOM-колекцій як `obj[Symbol.iterator]()`.

---

## Ітеровані об'єкти (iterable protocol)

Об'єкт ітерований, якщо має метод під ключем `Symbol.iterator`, що повертає ітератор.

Перевірка ітерованості:

```js
function isIterable(obj) {
  return obj != null && typeof obj[Symbol.iterator] === 'function';
}
```

Можна зробити об'єкт ітерованим, додавши `[Symbol.iterator]` (на об'єкті або в прототипі). Оператор розпилення `...` та `for...of` споживають ітеровані об'єкти.

---

## Генератори (function* та yield)

Генератори — функції, які повертають ітератори. Використовують `function*` і `yield`.

```js
function* sequence() {
  yield 1;
  yield 3;
  yield 5;
}

const seq = sequence();
seq.next(); // {value:1, done:false}
for (const v of sequence()) console.log(v); // 1,3,5
```

Коротко про поведінку:

- Виклик генератора повертає ітератор, тіло функції не виконується відразу.
- `next()` відновлює виконання до наступного `yield`.
- `next(value)` передає `value` всередину призупиненого `yield`.
- Генератори дозволяють ліниву генерацію послідовностей (lazy), в т.ч. нескінченні послідовності.

Приклад генератора, що отримує значення:

```js
function* gen() {
  const a = yield 10;
  const b = yield a + 5;
  yield b;
}

const it = gen();
it.next();       // {value:10, done:false}
it.next(15);     // {value:20, done:false}  // a = 15, yield 15+5
it.next(60);     // {value:60, done:false}  // b = 60
it.next();       // {value:undefined, done:true}
```

---

## Просунуті генератори

- `iterator.return(value)` закриває генератор і повертає `{ value, done: true }`.
- `iterator.throw(err)` кине помилку в точці призупинення `yield`; якщо не оброблена всередині, помилка піднімається і генератор закривається.
- `yield* iterable` делегує іншому ітерованому об'єкту (або генератору), по черзі повертаючи його елементи.

Приклад делегації:

```js
function* a() { yield* [1,2,3]; }
[...a()]; // [1,2,3]
```

Збір делегованої послідовності в рядок:

```js
function* wholeNums() { for (let i=1;i<=5;i++) yield i; }
function* squareNums() { for (let i=1;i*i<=50;i++) yield i*i; }
function* cubeNums() { for (let i=1;i**3<=100;i++) yield i**3; }

function* gen() {
  yield* wholeNums();
  yield* squareNums();
  yield* cubeNums();
}

// Однорядковий лог послідовності як рядок:
console.log([...gen()].join(', '));
```

---

## Поради та кращі практики

- Використовуйте приватні поля `#` у класах для суворої інкапсуляції.
- Віддавайте перевагу вбудованим ітераторам або генераторам для лінивих обчислень замість створення великих масивів.
- Будьте обережні з нескінченними генераторами в `for...of` або при розпиленні — вони ніколи не завершаться.

---

## Питання на співбесіді (Interview Questions)

- Що таке iterator protocol? Які його вимоги?
- Чим відрізняється iterable від iterator?
- Як працює for...of під капотом?
- Як працює yield у генераторі? Що повертає next()?
- Що роблять iterator.return() та iterator.throw()?
- У чому різниця між yield та yield*?
- Як зробити звичайний об'єкт ітерованим?
- Як передавати значення всередину генератора через next(value)?
- Як обробляти/пробросити помилки в генераторі (throw)?
- Коли використовувати генератори замість звичайних масивів/функцій (переваги/ризики)?
- Як безпечно делегувати генератор іншому iterable і отримати його return-значення?

## Як відповідати (What to Answer)

### Відповіді — коротко та технічно

- Що таке iterator protocol? Які його вимоги?
  Iterator protocol — контракт для об'єкта-ітератора: він має метод next(), який повертає об'єкт { value, done }. done — булеве, value — будь-яке значення (може бути undefined). Опціонально ітератор може мати return(value) і throw(err).

- Чим відрізняється iterable від iterator?
  Iterable — об'єкт з методом [Symbol.iterator]() → iterator. Iterator — об'єкт з методом next() → {value, done}. Тобто iterable «виробляє» iterator'и; iterator сам відповідає за послідовність.

- Як працює for...of під капотом?
  1) Викликає obj[Symbol.iterator]() → отримує iterator.
  2) Повторно викликає iterator.next() і бере value поки next().done !== true.
  3) Якщо цикл перервано раніше (break, return, throw), то викликає iterator.return() якщо він існує (для очищення).

- Як працює yield у генераторі? Що повертає next()?
  yield — точка призупинення: при досягненні yield генератор повертає { value: <вираження>, done: false } і зупиняється. Виклик next(value) відновлює виконання; вираз yield повертає значення, передане до next(). next() повертає наступний {value, done}. Перший next() запускає виконання до першого yield; значення, передане в перший next(value), ігнорується (не присвоюється жодному yield).

  При завершенні функції-генератора next() повертає { value: <optional return>, done: true }.

- Що роблять iterator.return() та iterator.throw()?
  - return(value): закриває генератор/ітератор і повертає { value, done: true }. Викликається вручну або автоматично при ранньому виході з for...of для виконання cleanup (try/finally всередині генератора).
  - throw(err): вкидає помилку в тіло генератора в місці останнього yield; якщо генератор її не обробить (try/catch), помилка піднімається зовні і генератор закривається.

- У чому різниця між yield та yield*?
  - yield — повертає одиночне значення з генератора.
  - yield*iterable — делегує ітерацію іншому iterable/generator: по черзі повертає його значення. Крім того, результат yield* (вираз) — це return-значення делегованого генератора, якщо він повернув щось через return.

- Як зробити звичайний об'єкт ітерованим?
  Додати метод [Symbol.iterator], що повертає iterator. Наприклад, простий спосіб через генератор:

  ```js
  const obj = {
    items: [1,2,3],
    [Symbol.iterator]() {
      return (function* () { yield* this.items }).call(this);
    }
  };
  // або
  // [Symbol.iterator]: function* () { yield* this.items }
  ```

- Як передавати значення всередину генератора через next(value)?
  Значення, передане в next(value), повертається як результат виразу yield всередині генератора, тобто:

  ```js
  function* g() {
    const a = yield 1; // a отримає значення, яке передано в наступний next(...)
  }
  const it = g();
  it.next();      // запускає та повертає 1
  it.next(42);    // тут a = 42
  ```

- Як обробляти/пробросити помилки в генераторі (throw)?
  - Всередині генератора використовуйте try/catch навколо yield для локальної обробки.
  - Зовні можна викликати iterator.throw(err) щоб вкинути помилку в точку призупинення; якщо генератор її зловить — виконання може продовжитись, ітератор поверне наступні значення. Якщо не зловлено — помилка піднімається зовні.
  - Для гарантованого очищення використовують try/finally у генераторі; тоді при iterator.return() або при необробленій помилці виконається cleanup.

  Приклад:

  ```js
  function* g() {
    try {
      yield 1;
    } catch (e) {
      console.log('handled', e);
    } finally {
      console.log('cleanup');
    }
  }
  const it = g();
  it.next();
  it.throw(new Error('oops')); // потрапить у catch, потім finally
  ```

- Коли використовувати генератори замість звичайних масивів/функцій (переваги/ризики)?
  Переваги:
  - Ліниве (по запиту) вироблення елементів — економія пам'яті для великих/нескінченних послідовностей.
  - Зручні для складних потоків даних, пайплайнів, пошагового обчислення та кооперативної асинхронності (в старих підходах).
  - Можуть делегувати підзадачі yield* і легко контролювати виконання.
  Ризики / обмеження:
  - Ускладнюють читаність і дебаг через неконвертований потік управління.
  - Невеликий runtime-наклад порівняно з простими функціями/масивами.
  - Нескінченні генератори небезпечні при розпиленні або for...of без умов виходу.
  - Не завжди підходять для паралельної/розподіленої обробки або серіалізації.

- Як безпечно делегувати генератор іншому iterable і отримати його return-значення?
  Використовуйте yield* і присвоєння результату виразу:

  ```js
  function* child() {
    yield 1;
    yield 2;
    return 'done';
  }

  function* parent() {
    const res = yield* child(); // res === 'done'
    console.log('child returned', res);
    yield 3;
  }

  console.log([...parent()]); // [1,2,3]
  ```

  Якщо потрібно обробити помилки делегованого генератора, можна обгорнути yield* в try/catch або передавати throw/return зовні — делегування автоматично передає зовнішні throw()/return() внутрішньому iterator'у.
