# Модулі

Модулі інкапсулюють код (функції, змінні, класи) та дають можливість використовувати їх у інших файлах. Умовно: один файл = один модуль. Стандарт модулів з'явився в ES2015 і зараз підтримується в браузерах та Node.js.

---

## Основна ідея

- export позначає публічні сутності модуля.
- import імпортує експортовані сутності з іншого модуля.
- У браузері потрібно використовувати `<script type="module">` для модульних скриптів.

**Приклад:**

```js
// sayHi.js
export function sayHi(user) {
  return `Hello, ${user}!`;
}

// main.js
import { sayHi } from './sayHi.js';
console.log(sayHi('John'));
```

> **Заувага:** модулі працюють через HTTP(s), не через file:// — для локальної розробки запускайте локальний сервер або Live Server.

---

## Ключові відмінності від класичних скриптів

- Завжди strict mode.
- Топ-рівень область видимості модуля — локальна (не глобальна).
- Код модуля виконується лише один раз — перший імпорт ініціює виконання.
- Топ-рівневе this в модулі — undefined.
- `<script type="module">` за замовчуванням defer (відкладене виконання).
- Для зовнішніх модулів з іншого походження потрібні CORS-заголовки.
- Браузер не дозволяє "bare" імпорти (без шляху) без import map.

---

## import.meta

Об'єкт з мета-даними поточного модуля (у браузері містить URL): `import.meta.url`.

---

## Export / Import — синтаксичні варіанти

- Експорт перед оголошенням:

  ```js
  export function f() {}
  export const X = 1;
  ```

- Окремий список експорту:

  ```js
  function f() {}
  export { f };
  ```

- Імпорт поіменований:

  ```js
  import { f, X } from './mod.js';
  ```

- Імпорт всього як об'єкт:

  ```js
  import * as Mod from './mod.js';
  ```

- Псевдоніми:

  ```js
  import { f as fn } from './mod.js';
  export { f as fn };
  ```

- export default — один дефолтний експорт на файл:

  ```js
  export default class User {}
  import User from './user.js';
  ```

> Порада: деякі команди уникають default-експортів, бо імпорт можна перейменувати довільно.

---

## Re-export (перепакування)

Можна реекспортувати з іншого модуля:

```js
export { login } from './helpers.js';
export * from './utils.js'; // реекспортує лише іменовані експорти, не default
export { default as User } from './user.js';
```

Це корисно для створення "entry" файлу пакета (збірки API).

---

## Динамічний import()

`import(modulePath)` повертає Promise, що резолвиться в об'єкт модуля:

```js
const mod = await import('./say.js');
mod.hi();
```

- Працює і в класичних скриптах (не вимагає type="module").
- Використовується для lazy-loading та умовного завантаження.

---

## Top-level await

У модулях можна використовувати await на верхньому рівні — інші модулі, які імпортують цей модуль, чекатимуть завершення, але це не блокує паралельне завантаження інших модулів.

---

## Import maps

Import maps дозволяють перетворювати "bare" імена на конкретні URL у браузері, наприклад для локального мапінгу залежностей. Визначаються через `<script type="importmap">`.

---

## Завантаження не-JS ресурсів

Можна імпортувати JSON, CSS тощо з явною вказівкою типу:

```js
import colors from './colors.json' with { type: 'json' };
```

---

## Кешування та однакратне виконання

Модуль виконується один раз; експорти — "живі зв'язки" (live bindings). Якщо модуль експортує об'єкт і інший модуль змінює його властивість, зміни будуть видимі в усіх імпортерах.

При циклічних імпортах будьте обережні: доступ до ще не ініціалізованих змінних викличе ReferenceError; асинхронне використання може уникнути проблем.

---

## Інтеграція з Node.js та CommonJS

- Node.js підтримує як CommonJS (require/module.exports), так і ESModules (import/export, .mjs або налаштування package.json).
- CommonJS модулі виконуються в обгортці й кешуються; require повертає module.exports.
- При роботі в Node знайте про відмінності (синхронна ініціалізація, відмінність у семантиці імпортів).

---

## Поради для практики

- Тримайте один "feature" на файл — легше читати і навігувати.
- Використовуйте іменовані експорти для ясності; default — коли модуль експортує одну головну сутність.
- Мінімізуйте циклічні залежності: винесіть спільний код у третій модуль.
- Для production використовуйте бандлери (Webpack, Vite) для оптимізації, tree-shaking, мініфікації.
- Перевіряйте локально через сервер (GitHub Pages, http-server, Live Server).

---

## Interview Questions

- Що таке ES-модуль? Чим відрізняється від скрипта без type="module"?
- Як працює import/export під капотом? Що таке live bindings?
- Чим відрізняються named exports і default export? Які плюси/мінуси?
- Що робить import() і коли його використовувати?
- Як працює кешування модулів і чому модуль виконується лише один раз?
- Що таке import.meta і навіщо це потрібно?
- Як уникати проблем з циклічними імпортами?
- Які відмінності між ESModules і CommonJS (в Node.js)?

---

## What to Answer

- **Що таке ES-модуль? Чим відрізняється від скрипта без type="module"?**
  ES-модуль — це JS-файл із import/export. Відмінності: модулі завжди у strict mode, мають власну область видимості, виконуються лише один раз, а `<script type="module">` автоматично defer. Звичайний скрипт — глобальний, без імпортів/експортів.

- **Як працює import/export під капотом? Що таке live bindings?**
  export робить сутність доступною для інших модулів, import підключає її. Live bindings означає, що імпортовані змінні — це "живі посилання": якщо змінити експортовану змінну, зміни побачать усі імпортери.

  ```js
  // a.js
  export let count = 1;
  // b.js
  import { count } from './a.js';
  ```

- **Чим відрізняються named exports і default export? Які плюси/мінуси?**
  Named export: можна експортувати кілька сутностей, імпортувати за іменем. Default export: лише один на файл, імпортується з довільним ім’ям.
  Плюси named: читабельність, автодоповнення, складніше помилитись. Default — зручно для головної сутності, але ім'я при імпорті можна змінити, що знижує однозначність.

- **Що робить import() і коли його використовувати?**
  import() — динамічний імпорт, повертає Promise з модулем. Корисно для lazy-loading (завантаження по потребі), умовних імпортів.

  ```js
  const mod = await import('./feature.js');
  ```

- **Як працює кешування модулів і чому модуль виконується лише один раз?**
  При першому імпорті модуль виконується і кешується; наступні імпорти повертають вже ініціалізований експорт. Це економить ресурси й гарантує єдиний стан.

- **Що таке import.meta і навіщо це потрібно?**
  import.meta — об'єкт із метаданими модуля. Наприклад, import.meta.url містить URL поточного модуля; корисно для динамічного завантаження ресурсів.

- **Як уникати проблем з циклічними імпортами?**
  Ризик: доступ до ще не ініціалізованих змінних (ReferenceError). Рішення: винести спільний код у окремий модуль, уникати звернення до неініціалізованих експортів, використовувати асинхронний код.

- **Які відмінності між ESModules і CommonJS (в Node.js)?**
  ESModules — import/export, асинхронне завантаження, live bindings, .mjs або type: "module". CommonJS — require/module.exports, синхронне завантаження, експорти копіюються, .js. Важливо: не можна змішувати синтаксис у одному файлі.

**Практика:**

- Модулі працюють лише через HTTP(s), не через file://
- Для production — використовуйте бандлери (Webpack, Vite)
- Для зовнішніх модулів потрібен CORS
