# Модулі

Модулі інкапсулюють код (функції, змінні, класи) та дають можливість використовувати їх у інших файлах. Умовно: один файл = один модуль. Стандарт модулів з'явився в ES2015 і зараз підтримується в браузерах та Node.js.

---

## Основна ідея

- export позначає публічні сутності модуля.
- import імпортує експортовані сутності з іншого модуля.
- У браузері потрібно використовувати <script type="module"> для модульних скриптів.

Приклад:

```js
// sayHi.js
export function sayHi(user) {
  return `Hello, ${user}!`;
}

// main.js
import { sayHi } from './sayHi.js';
console.log(sayHi('John'));
```

Заувага: модулі працюють через HTTP(s), не через file:// — для локальної розробки запускайте локальний сервер або Live Server.

---

## Ключові відмінності від класичних скриптів

- Завжди strict mode.
- Топ-рівень область видимості модуля — локальна (не глобальна).
- Код модуля виконується лише один раз — перший імпорт ініціює виконання.
- Топ-рівневе this в модулі — undefined.
- <script type="module"> за замовчуванням defer (відкладене виконання).
- Для зовнішніх модулів з іншого походження потрібні CORS-заголовки.
- Браузер не дозволяє "bare" імпорти (без шляху) без import map.

---

## import.meta

Об'єкт з мета-даними поточного модуля (у браузері містить URL): import.meta.url.

---

## Export / Import — синтаксичні варіанти

- Експорт перед оголошенням:
  export function f() {}
  export const X = 1;

- Окремий список експорту:
  function f() {}
  export { f };

- Імпорт поіменований:
  import { f, X } from './mod.js';

- Імпорт всього як об'єкт:
  import * as Mod from './mod.js';

- Псевдоніми:
  import { f as fn } from './mod.js';
  export { f as fn };

- export default — один дефолтний експорт на файл:
  export default class User {}
  import User from './user.js';

Порада: деякі команди уникають default-експортів, бо імпорт можна перейменувати довільно.

---

## Re-export (перепакування)

Можна реекспортувати з іншого модуля:

export { login } from './helpers.js';
export * from './utils.js'; // реекспортує лише іменовані експорти, не default
export { default as User } from './user.js';

Це корисно для створення "entry" файлу пакета (збірки API).

---

## Динамічний import()

import(modulePath) повертає Promise, що резолвиться в об'єкт модуля:

```js
const mod = await import('./say.js');
mod.hi();
```

- Працює і в класичних скриптах (не вимагає type="module").
- Використовується для lazy-loading та умовного завантаження.

---

## Top-level await

У модулях можна використовувати await на верхньому рівні — інші модулі, які імпортують цей модуль, чекатимуть завершення, але це не блокує паралельне завантаження інших модулів.

---

## Import maps

Import maps дозволяють перетворювати "bare" імена на конкретні URL у браузері, наприклад для локального мапінгу залежностей. Визначаються через <script type="importmap">.

---

## Завантаження не-JS ресурсів

Можна імпортувати JSON, CSS тощо з явною вказівкою типу:

import colors from './colors.json' with { type: 'json' };

---

## Кешування та однакратне виконання

Модуль виконується один раз; експорти — "живі зв'язки" (live bindings). Якщо модуль експортує об'єкт і інший модуль змінює його властивість, зміни будуть видимі в усіх імпортерах.

При циклічних імпортах будьте обережні: доступ до ще не ініціалізованих змінних викличе ReferenceError; асинхронне використання може уникнути проблем.

---

## Інтеграція з Node.js та CommonJS

- Node.js підтримує як CommonJS (require/module.exports), так і ESModules (import/export, .mjs або налаштування package.json).
- CommonJS модулі виконуються в обгортці й кешуються; require повертає module.exports.
- При роботі в Node знайте про відмінності (синхронна ініціалізація, відмінність у семантиці імпортів).

---

## Поради для практики

- Тримайте один "feature" на файл — легше читати і навігувати.
- Використовуйте іменовані експорти для ясності; default — коли модуль експортує одну головну сутність.
- Мінімізуйте циклічні залежності: винесіть спільний код у третій модуль.
- Для production використовуйте бандлери (Webpack, Vite) для оптимізації, tree-shaking, мініфікації.
- Перевіряйте локально через сервер (GitHub Pages, http-server, Live Server).

---

## Interview Questions

- Що таке ES-модуль? Чим відрізняється від скрипта без type="module"?
- Як працює import/export під капотом? Що таке live bindings?
- Чим відрізняються named exports і default export? Які плюси/мінуси?
- Що робить import() і коли його використовувати?
- Як працює кешування модулів і чому модуль виконується лише один раз?
- Що таке import.meta і навіщо це потрібно?
- Як уникати проблем з циклічними імпортами?
- Які відмінності між ESModules і CommonJS (в Node.js)?

---

## What to Answer

- Дайте коротке визначення, потім одну‑дві ключові технічні деталі і невеликий приклад.
  - Наприклад: "ES-модуль — файл із import/export; браузер викликає obj[Symbol.iterator]()…" (пояснення під конкретне питання).
- Для питання про default vs named поясніть семантику і практичні наслідки (перейменування при імпорті, читабельність, зручність для бандлерів).
- Для import() скажіть, коли це корисно (lazy-loading, умовні завантаження) і що повертає (Promise → об'єкт модуля).
- Для циклів: опишіть ризик (доступ до неініціалізованих змінних) і запропонуйте рішення (рефакторинг, винесення в окремий модуль).
- Підкресліть практичність: mention bundlers, CORS для зовнішніх модулів, що модулі працюють тільки через HTTP(s).
