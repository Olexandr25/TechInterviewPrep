# Indexes

**Indexes** в SQL — це об'єкти бази даних, які прискорюють пошук і вибірку даних у таблицях. Вони працюють як індекс у книзі: дозволяють швидко знаходити рядки за певними значеннями стовпців, не скануючи всю таблицю. Індекси створюють окрему структуру даних, яку використовує СУБД для оптимізації SELECT-запитів. Водночас, індекси можуть уповільнювати операції INSERT, UPDATE, DELETE, оскільки їх структура потребує оновлення при зміні даних.

---

## Основи індексування

- **Створення індексу:**

  ```sql
  CREATE INDEX idx_name ON table_name(column_name);
  ```

- **Видалення індексу:**

  ```sql
  DROP INDEX idx_name ON table_name;
  ```

- **Типи індексів:**
  - Одиночний (single-column)
  - Складений (composite, multi-column)
  - Унікальний (UNIQUE)
- **Використовуйте індекси для стовпців, які часто використовуються у WHERE, JOIN, ORDER BY.**

---

## Query Optimization (Оптимізація запитів)

- **Оптимізація запитів** — це процес покращення швидкості виконання SQL-запитів і зменшення використання ресурсів.
- Основні стратегії:
  - Індексування стовпців, що часто використовуються у WHERE, JOIN, ORDER BY.
  - Вибирайте лише потрібні стовпці (уникайте SELECT *).
  - Фільтруйте рядки на ранніх етапах запиту.
  - Використовуйте ефективні типи JOIN і правильний порядок об'єднання.
  - Уникайте підзапитів, якщо можна замінити їх на JOIN або CTE.
  - Використовуйте LIMIT для обмеження кількості рядків.
  - Уникайте надмірного використання wildcard (%...) у LIKE на початку рядка.
  - Використовуйте EXISTS замість COUNT для перевірки наявності записів.
  - Аналізуйте план виконання запиту (EXPLAIN).
  - Регулярно оновлюйте статистику таблиць.
  - Використовуйте специфічні для СУБД оптимізації (наприклад, партиціювання, матеріалізовані view).

---

## Managing Indexes (Управління індексами)

- **Створення, зміна, видалення індексів** — важлива частина адміністрування БД.
- Визначайте, які стовпці найчастіше використовуються у фільтрації, сортуванні, об'єднанні.
- Не створюйте індекси на всі стовпці — це уповільнить зміну даних.
- Регулярно аналізуйте ефективність індексів (наприклад, за допомогою ANALYZE TABLE).
- Проводьте періодичне обслуговування: перебудова (REBUILD), реорганізація (REORGANIZE).

---

## 12 порад для оптимізації SQL-запитів

1. **Використовуйте індекси ефективно** — індексуйте часто використовувані стовпці.
2. **Уникайте SELECT *** — вибирайте лише потрібні поля.
3. **Зменшуйте використання wildcard (%)** — особливо на початку рядка у LIKE.
4. **Використовуйте відповідні типи даних** — це пришвидшує пошук і зменшує розмір таблиці.
5. **Обмежуйте кількість рядків** — використовуйте LIMIT.
6. **EXISTS замість COUNT** — для перевірки наявності записів.
7. **Уникайте підзапитів, якщо можна використати JOIN**.
8. **Використовуйте можливості хмарних СУБД** — автоматичне масштабування, оптимізація.
9. **Моніторинг продуктивності** — аналізуйте час виконання, профілюйте запити.
10. **Використовуйте AI/ML для автоматичної оптимізації** (якщо доступно).
11. **Мікросервісна архітектура** — розділяйте великі БД на менші.
12. **Використовуйте спеціалізоване ПЗ для великих навантажень** (наприклад, Apache Spark).

---

## Interview Questions

- Що таке індекс у SQL? Для чого він потрібен?
- Які типи індексів існують?
- Як індекси впливають на SELECT, INSERT, UPDATE, DELETE?
- Як створити, змінити або видалити індекс?
- Як визначити, які стовпці потрібно індексувати?
- Які основні підходи до оптимізації SQL-запитів?
- Чому не варто індексувати всі стовпці?
- Як перевірити ефективність індексів?
- Які ще способи оптимізації запитів, окрім індексів, ви знаєте?

---

## What to Answer

- **Що таке індекс у SQL? Для чого він потрібен?**
  - Індекс — це спеціальна структура даних, яка прискорює пошук і вибірку рядків у таблиці за певними стовпцями. Дозволяє швидко знаходити потрібні дані без повного сканування таблиці.

- **Які типи індексів існують?**
  - Одиночний (single-column) — індексує один стовпець.
  - Складений (composite, multi-column) — індексує комбінацію кількох стовпців.
  - Унікальний (UNIQUE) — гарантує унікальність значень у стовпці/стовпцях.
  - Повнотекстовий (FULLTEXT), просторовий (SPATIAL) — специфічні для деяких СУБД.

- **Як індекси впливають на SELECT, INSERT, UPDATE, DELETE?**
  - SELECT — значно прискорює пошук і вибірку.
  - INSERT/UPDATE/DELETE — можуть уповільнювати, бо індекс потрібно оновлювати при кожній зміні даних.

- **Як створити, змінити або видалити індекс?**
  - Створити:

    ```sql
    CREATE INDEX idx_name ON table_name(column_name);
    ```

  - Видалити:

    ```sql
    DROP INDEX idx_name ON table_name;
    ```

  - Змінити — зазвичай видаляють старий і створюють новий індекс із потрібними параметрами.

- **Як визначити, які стовпці потрібно індексувати?**
  - Індексувати варто стовпці, які часто використовуються у WHERE, JOIN, ORDER BY, а також ті, що забезпечують унікальність або часто фільтруються.

- **Які основні підходи до оптимізації SQL-запитів?**
  - Використання індексів.
  - Вибір лише потрібних стовпців (уникати SELECT *).
  - Фільтрація рядків на ранніх етапах (WHERE).
  - Ефективне використання JOIN-ів.
  - Обмеження кількості рядків (LIMIT).
  - Аналіз плану виконання (EXPLAIN).
  - Використання EXISTS замість COUNT для перевірки наявності записів.
  - Уникати підзапитів, якщо можна використати JOIN або CTE.

- **Чому не варто індексувати всі стовпці?**
  - Кожен індекс уповільнює INSERT/UPDATE/DELETE, займає додаткове місце і потребує обслуговування. Надмірна кількість індексів може знизити загальну продуктивність БД.

- **Як перевірити ефективність індексів?**
  - Аналізувати план виконання запиту (EXPLAIN).
  - Використовувати статистику використання індексів (ANALYZE TABLE, SHOW INDEX).
  - Періодично переглядати і видаляти невикористовувані індекси.

- **Які ще способи оптимізації запитів, окрім індексів, ви знаєте?**
  - Використання партиціювання таблиць.
  - Матеріалізовані view.
  - Кешування результатів.
  - Переписування запитів для зменшення обсягу оброблюваних даних.
  - Використання відповідних типів даних.
  - Мікросервісна архітектура для розділення великих БД.
