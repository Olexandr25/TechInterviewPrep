# Merge Strategies in Git

## Fast-Forward vs Non-FF

У Git при злитті гілок існують два основних типи merge: Fast-Forward та Non-Fast-Forward (No-FF). Важливо розуміти різницю між ними для ефективного керування історією комітів.

- **Fast-Forward merge** відбувається, коли цільова гілка (наприклад, main) не відхилялася від гілки, яку ви зливаєте (наприклад, feature). У цьому випадку історія цільової гілки є підмножиною історії feature-гілки. Git просто пересуває покажчик цільової гілки вперед до останнього коміту feature-гілки. Новий merge-коміт не створюється, історія залишається лінійною.

- **Non-Fast-Forward (No-FF) merge** виникає, коли цільова гілка вже має власні коміти або ви явно вказуєте створити merge-коміт. Git створює новий коміт злиття, який має двох батьків: один з цільової гілки, інший — з feature-гілки. Merge-коміт фіксує об'єднання змін і зберігає історію обох гілок.

### Interview Questions - Fast-Forward vs Non-FF

- У чому різниця між Fast-Forward та Non-Fast-Forward merge?
- Коли варто використовувати Non-FF merge?

### What to Answer - Fast-Forward vs Non-FF

- Fast-Forward merge не створює merge-коміт, просто пересуває покажчик гілки вперед; Non-FF merge створює окремий merge-коміт, що зберігає історію обох гілок.
- Non-FF merge варто використовувати для збереження історії гілок та кращої видимості злиттів у проекті.

---

## Rebase

Rebase у Git — це потужна, але потенційно складна операція, яка дозволяє змінювати або реорганізовувати послідовність комітів. Основна мета rebase — зробити історію проекту чистішою та лінійнішою, перемістивши або об'єднавши зміни з однієї гілки в іншу.

### Interview Questions - Rebase

- Для чого використовується rebase?
- Яка різниця між merge та rebase?

### What to Answer - Rebase

- Rebase використовується для переписування історії комітів, щоб зробити її лінійною та чистою.
- Merge зберігає всі гілки та створює merge-коміт, а rebase переписує коміти так, ніби вони були створені поверх нової бази.

---

## Squash

Squash у Git — це процес об'єднання кількох комітів в один. Це часто робиться для створення чистішої та коротшої історії комітів, особливо перед злиттям feature-гілки в основну.

### Interview Questions - Squash

- Що таке squash у Git?
- Коли доцільно використовувати squash?

### What to Answer - Squash

- Squash — це об'єднання кількох комітів в один для спрощення історії.
- Squash доцільно використовувати перед злиттям, щоб уникнути "засмічення" історії дрібними комітами.

---

## Handling Conflicts

Коли кілька розробників працюють над одним проектом одночасно, під час злиття можуть виникати конфлікти. Це трапляється, коли зміни різних людей перетинаються або суперечать одна одній у певному файлі. У таких випадках Git дозволяє вручну вирішити конфлікти та об'єднати зміни.

### Interview Questions - Handling Conflicts

- Що таке merge conflict?
- Як вирішити конфлікт у Git?

### What to Answer - Handling Conflicts

- Merge conflict — це ситуація, коли зміни з різних гілок не можуть бути автоматично об'єднані Git.
- Для вирішення конфлікту потрібно вручну відредагувати файли, позначені як конфліктні, а потім закомітити зміни.

---

## Cherry Picking Commits

Cherry-picking у Git дозволяє застосувати окремий коміт з однієї гілки до іншої без злиття всієї гілки. Це корисно, коли потрібно перенести конкретну фічу або виправлення з однієї гілки в іншу, не включаючи всі зміни з джерельної гілки.

### Interview Questions - Cherry Picking Commits

- Для чого використовується cherry-pick?
- Яка команда для cherry-pick у Git?

### What to Answer - Cherry Picking Commits

- Cherry-pick використовується для вибіркового перенесення окремих комітів між гілками.
- Для cherry-pick використовується команда: `git cherry-pick <commit-hash>`.
